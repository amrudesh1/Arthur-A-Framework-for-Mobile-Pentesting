import os
import sys
import subprocess
from Arthur import apktool as apk
import shutil
import xml.etree.ElementTree

apktool = apk.Apktool()


class Patcher:
    def __init__(self, args):
        self.package_name = args.package
        self.args = args
        self.checkPackageValidity()

    def checkPackageValidity(self):
        args = ["adb", "shell", "pm", "list", "packages"]
        proc = subprocess.run(args, stdout=subprocess.PIPE)
        packages = proc.stdout.decode("utf-8").split("\n")
        if "package:" + self.package_name in packages:
            self.startApkPatcher()
        else:
            print("Package not found")
            sys.exit(1)

    def startApkPatcher(self):
        apk_paths = self.pullApkFromDevice()
        print(apk_paths)

    def pullApkFromDevice(self):
        args = ["adb", "shell", "pm", "path", self.package_name]
        proc = subprocess.run(args, stdout=subprocess.PIPE)
        apk_paths = proc.stdout.decode("utf-8").split()
        localapks = []
        os.chdir("Arthur/temp/")
        for paths in apk_paths:
            baseapkname = paths.split('/')[-1]
            paths = paths.replace('package:', '')
            localapks.append(os.path.join(
                os.getcwd(), self.package_name + "-" + baseapkname))
            print("Pulling [**]" + paths)
            ret = subprocess.run(
                ["adb", "pull", paths, localapks[-1]], stdout=getStdout())
            if ret.returncode != 0:
                print("Error: Failed to run 'adb pull " +
                      paths + " " + localapks[-1])
                sys.exit(1)
            print("")
        print("APK Successfully pulled from Device")
        if len(localapks) == 1:
            return localapks[0]
        else:
            return self.combineSplitAPKs(localapks)

    def combineSplitAPKs(self, localapks):
        print("APK Split Detected Combining the split APKs")
        baseapkdir = os.path.join("Arthur/temp", self.package_name + "-base")
        baseapkfilename = self.package_name + "-base.apk"
        splitapkpaths = []
        for apkpath in localapks:
            print("[+] Extracting: " + apkpath)
            apkdir = apkpath[:-4]
            ret = apktool.runApkTool(["d", apkpath, "-o", apkdir])
            if ret.returncode != 0:
                print(
                    "Error: Failed to run 'apktool d " + apkpath + " -o " + apkdir + "'.\nRun with --debug-output for more information.")
                sys.exit(1)

        if apkpath.endswith("base.apk") == False:
            splitapkpaths.append(apkdir)

        # Detect Proguard Logic needed to be add here to warn the user

        self.copyExtractedFiles(baseapkdir, splitapkpaths)
        self.fixPublicResourceIDs(baseapkdir, splitapkpaths)
        self.hackRemoveDuplicateStyleEntries(baseapkdir)
        self.disableApkSplitting(baseapkdir)

        print("Rebuilding as a single APK.")
        if os.path.exists(os.path.join(baseapkdir, "res", "navigation")) == True:
            print(
                "[+] Found res/navigation directory, rebuilding with 'apktool --use-aapt2'.")
            ret = apktool.runApkTool(["--use-aapt2", "b", baseapkdir])
            if ret.returncode != 0:
                print("Error: Failed to run 'apktool b " + baseapkdir +
                      "'.\nRun with --debug-output for more information.")
                sys.exit(1)
            ret = apktool.runApkTool(["--use-aapt2", "b", baseapkdir])
            if ret.returncode != 0:
                print("Error: Failed to run 'apktool b " + baseapkdir +
                      "'.\nRun with --debug-output for more information.")
                sys.exit(1)
        else:
            # print("[+] Building APK with apktool.")
            # ret = apktool.runApkTool(["b", baseapkdir])
            # if ret.returncode != 0:
            #     print("Error: Failed to run 'apktool b " + baseapkdir +
            #           "'.\nRun with --debug-output for more information.")
            #     sys.exit(1)
            pass

    def copyExtractedFiles(self, baseapkdir, splitapkpaths):
        os.chdir("../..")
        print("Copying files and directories from split APKs into base APK.")
        for apkdir in splitapkpaths:
            for (root, dirs, files) in os.walk(apkdir):
                if root.startswith(os.path.join(apkdir, "original")) == False:

                    for d in dirs:
                        p = baseapkdir + os.path.join(root, d)[len(apkdir):]

                        if os.path.exists(p) == False:
                            os.mkdir(p)

                    for f in files:
                        if apkdir == root and (f == "AndroidManifest.xml" or f == "apktool.yml"):
                            continue

                        p = baseapkdir + os.path.join(root, f)[len(apkdir):]

                        # Copy files into the base APK, except for XML files in the res directory
                        if f.lower().endswith(".xml") and p.startswith(os.path.join(baseapkdir, "res")):
                            continue

                        file_path = os.path.join(root, f)
                        dest_path = p
                        shutil.move(file_path, dest_path)

    def fixPublicResourceIDs(self, baseapkdir, splitapkpaths):
        # Bail if the base APK does not have a public.xml
        if os.path.exists(os.path.join(baseapkdir, "res", "values", "public.xml")) == False:
            return
        print("Found public.xml in the base APK, fixing resource identifiers across split APKs.")

        # Mappings of resource IDs and names
        idToDummyName = {}
        dummyNameToRealName = {}

        # Step 1) Find all resource IDs that apktool has assigned a name of APKTOOL_DUMMY_XXX to.
        #        Load these into the lookup tables ready to resolve the real resource names from
        #        the split APKs in step 2 below.
        baseXmlTree = xml.etree.ElementTree.parse(
            os.path.join(baseapkdir, "res", "values", "public.xml"))
        for el in baseXmlTree.getroot():
            if "name" in el.attrib and "id" in el.attrib:
                if el.attrib["name"].startswith("APKTOOL_DUMMY_") and el.attrib["name"] not in idToDummyName:
                    idToDummyName[el.attrib["id"]] = el.attrib["name"]
                    dummyNameToRealName[el.attrib["name"]] = None
        print("[+] Resolving " + str(len(idToDummyName)) +
              " resource identifiers.")

        # Step 2) Parse the public.xml file from each split APK in search of resource IDs matching
        #        those loaded during step 1. Each match gives the true resource name allowing us to
        #        replace all APKTOOL_DUMMY_XXX resource names with the true resource names back in
        #        the base APK.
        found = 0
        for splitdir in splitapkpaths:
            if os.path.exists(os.path.join(splitdir, "res", "values", "public.xml")):
                tree = xml.etree.ElementTree.parse(
                    os.path.join(splitdir, "res", "values", "public.xml"))
                for el in tree.getroot():
                    if "name" in el.attrib and "id" in el.attrib:
                        if el.attrib["id"] in idToDummyName:
                            dummyNameToRealName[idToDummyName[el.attrib["id"]]
                                                ] = el.attrib["name"]
                            found += 1
        print("[+] Located " + str(found) + " true resource names.")

        # Step 3) Update the base APK to replace all APKTOOL_DUMMY_XXX resource names with the true
        #        resource name.
        updated = 0
        for el in baseXmlTree.getroot():
            if "name" in el.attrib and "id" in el.attrib:
                if el.attrib["name"] in dummyNameToRealName and dummyNameToRealName[el.attrib["name"]] is not None:
                    el.attrib["name"] = dummyNameToRealName[el.attrib["name"]]
                    updated += 1
        baseXmlTree.write(os.path.join(baseapkdir, "res", "values",
                          "public.xml"), encoding="utf-8", xml_declaration=True)
        print("[+] Updated " + str(updated) +
              " dummy resource names with true names in the base APK.")

        # Step 4) Find all references to APKTOOL_DUMMY_XXX resources within other XML resource files
        #        in the base APK and update them to refer to the true resource name.
        updated = 0
        for (root, dirs, files) in os.walk(os.path.join(baseapkdir, "res")):
            for f in files:
                if f.lower().endswith(".xml"):
                    try:
                        # Load the XML
                        tree = xml.etree.ElementTree.parse(
                            os.path.join(root, f))
                        # Register the namespaces and get the prefix for the "android" namespace
                        namespaces = dict([node for _, node in
                                           xml.etree.ElementTree.iterparse(os.path.join(baseapkdir, "AndroidManifest.xml"),
                                                                           events=["start-ns"])])
                        for ns in namespaces:
                            xml.etree.ElementTree.register_namespace(
                                ns, namespaces[ns])
                        ns = "{" + namespaces["android"] + "}"

                        # Update references to APKTOOL_DUMMY_XXX resources
                        changed = False
                        for el in tree.iter():
                            # Check for references to APKTOOL_DUMMY_XXX resources in attributes of this element
                            for attr in el.attrib:
                                val = el.attrib[attr]
                                if val.startswith("@") and "/" in val and val.split("/")[1].startswith("APKTOOL_DUMMY_") and \
                                        dummyNameToRealName[val.split("/")[1]] is not None:
                                    el.attrib[attr] = val.split(
                                        "/")[0] + "/" + dummyNameToRealName[val.split("/")[1]]
                                    updated += 1
                                    changed = True
                                elif val.startswith("APKTOOL_DUMMY_") and dummyNameToRealName[val] is not None:
                                    el.attrib[attr] = dummyNameToRealName[val]
                                    updated += 1
                                    changed = True

                            # Check for references to APKTOOL_DUMMY_XXX resources in the element text
                            val = el.text
                            if val is not None and val.startswith("@") and "/" in val and val.split("/")[1].startswith(
                                    "APKTOOL_DUMMY_") and dummyNameToRealName[val.split("/")[1]] is not None:
                                el.text = val.split(
                                    "/")[0] + "/" + dummyNameToRealName[val.split("/")[1]]
                                updated += 1
                                changed = True

                        # Save the file if it was updated
                        if changed == True:
                            tree.write(os.path.join(root, f),
                                       encoding="utf-8", xml_declaration=True)
                    except xml.etree.ElementTree.ParseError:
                        print("[-] XML parse error in " +
                              os.path.join(root, f) + ", skipping.")
        print("[+] Updated " + str(updated) +
              " references to dummy resource names in the base APK.")
        print("")

    def disableApkSplitting(self, baseapkdir):
        print("Disabling APK splitting in AndroidManifest.xml of base APK.")

        # Load AndroidManifest.xml
        tree = xml.etree.ElementTree.parse(
            os.path.join(baseapkdir, "AndroidManifest.xml"))

        # Register the namespaces and get the prefix for the "android" namespace
        namespaces = dict([node for _, node in
                           xml.etree.ElementTree.iterparse(os.path.join(baseapkdir, "AndroidManifest.xml"),
                                                           events=["start-ns"])])
        for ns in namespaces:
            xml.etree.ElementTree.register_namespace(ns, namespaces[ns])
        ns = "{" + namespaces["android"] + "}"

        # Disable APK splitting
        appEl = None
        elsToRemove = []
        for el in tree.iter():
            if el.tag == "application":
                appEl = el
                if ns + "isSplitRequired" in el.attrib:
                    del el.attrib[ns + "isSplitRequired"]
                if ns + "extractNativeLibs" in el.attrib:
                    el.attrib[ns + "extractNativeLibs"] = "true"
            elif appEl is not None and el.tag == "meta-data":
                if ns + "name" in el.attrib:
                    if el.attrib[ns + "name"] == "com.android.vending.splits.required":
                        elsToRemove.append(el)
                    elif el.attrib[ns + "name"] == "com.android.vending.splits":
                        elsToRemove.append(el)
        for el in elsToRemove:
            appEl.remove(el)

        # Save the updated AndroidManifest.xml
        tree.write(os.path.join(baseapkdir, "AndroidManifest.xml"),
                   encoding="utf-8", xml_declaration=True)
        print("")


    def hackRemoveDuplicateStyleEntries(self, baseapkdir):
        # Bail if there is no styles.xml
        if os.path.exists(os.path.join(baseapkdir, "res", "values", "styles.xml")) == False:
            return
        print("Found styles.xml in the base APK, checking for duplicate <style> -> <item> elements and removing.")
        print(
            "[~] Warning: this is a complete hack and may impact the visuals of the app, disable with --disable-styles-hack.")

        # Duplicates
        dupes = []

        # Parse styles.xml and find all <item> elements with duplicate names
        tree = xml.etree.ElementTree.parse(os.path.join(
            baseapkdir, "res", "values", "styles.xml"))
        for styleEl in tree.getroot().findall("style"):
            itemNames = []
            for itemEl in styleEl:
                if "name" in itemEl.attrib and itemEl.attrib["name"] in itemNames:
                    dupes.append([styleEl, itemEl])
                else:
                    itemNames.append(itemEl.attrib["name"])

        # Delete all duplicates from the tree
        for dupe in dupes:
            dupe[0].remove(dupe[1])

        # Save the result if any duplicates were found and removed
        if len(dupes) > 0:
            tree.write(os.path.join(baseapkdir, "res", "values",
                    "styles.xml"), encoding="utf-8", xml_declaration=True)
            print("[+] Removed " + str(len(dupes)) +
                " duplicate entries from styles.xml.")
        print("")


def getStdout():
    return None
