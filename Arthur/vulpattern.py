# Extract Vulnerability Pattern from Bytecode
import os
import xml.etree.ElementTree as eTree
import re
from collections import OrderedDict


class VulPattern:
    BYTE_CODE_STRING = 'Ljava/lang/String;'
    
    cbc_pattern = set()
    constant_key_for_pattern = set()
    exposed_credentials_pattern = set()
    dyn_broad_rec = set()
    empty_pending_intent = set()
    implicit_pending_intent = set()
    ssl_validity_vulnerability = set()
    host_name_verifier_vulnerability = set()
    insecure_ssl_vulnerability = set()
    invalid_certificate_authority_vulnerability = set()
    list_of_unenc_soc = set()

    def __init__(self, path):
        self.path = path
        self.package_name = self.get_package_name(
            os.path.join(self.path, 'AndroidManifest.xml'))
        self.byte_code_directory = os.path.join(self.path, 'ByteCode')
        self.analyse_byte_code()

    def get_package_name(self, manifest_path):
        xml_tree = eTree.parse(manifest_path)
        root = xml_tree.getroot()
        return root.attrib['package']

    def analyse_byte_code(self):
        if '.' in self.package_name:
            package_name = self.package_name.replace('.', '/')
            byte_code_path = os.path.join(self.path, 'smali', package_name)
        else:
            byte_code_path = os.path.join(
                self.path, 'smali', self.package_name)

        for root, dirs, files in os.walk(byte_code_path):
            print(files)
            for file in files:
                if file.endswith('.smali'):
                    smali_file_path = os.path.join(root, file)

                    # Find AES CBC Vulnerability
                    with open(smali_file_path, 'r') as smali_file:
                        for line in smali_file:
                            if 'AES/ECB/PKCS5Padding' in line or 'AES/ECB/NoPadding' in line or 'AES/ECB' in line:
                                self.cbc_pattern.add(smali_file_path)
                                print(
                                    '[+] Found AES CBC Vulnerability in %s' % smali_file_path)

                    # Find ConstantKey ForgeryAttack Vulnerability (SmartKeySpec Hardcoded Key)
                    # TODO:Variable Check Needs to be Implemented.
                    with open(smali_file_path, 'r') as smali_file:
                        line_count = 0
                        for index, line in enumerate(smali_file):
                            if 'Ljavax/crypto/spec/SecretKeySpec;' in line and 'new-instance' in line:
                                line_count += 1
                            if line_count > 0:
                                if 'sget-object' in line:
                                    break
                                if 'const-string' in line:
                                    self.constant_key_for_pattern.add(
                                        smali_file_path)
                                    print(
                                        '[+] Found ConstantKey ForgeryAttack Vulnerability in %s' % smali_file_path)
                                    break

                    # ExposedCredentials-InformationExposure-Lean
                    # TODO:Variable Check Needs to be Implemented.
                    with open(smali_file_path, 'r') as smali_file:
                        instance_line = False
                        line_count = 0
                        for index, line in enumerate(smali_file):
                            if 'Ljava/security/KeyStore$SecretKeyEntry' and 'new-instance' in line:
                                instance_line = True

                            if instance_line:
                                if 'Ljava/security/KeyStore$SecretKeyEntry' in line:
                                    line_count += 1

                                if line_count > 0:
                                    if (('const/4' in line) or ('const/16' in line)) and ('0x0' in line):
                                        self.exposed_credentials_pattern.add(
                                            smali_file_path)
                    # TODO: Salt Generation Vulnerability Pending

                    # DynamicRegBroadcastReceiver Vulnerability Check
                    # TODO: Check for Logical Mistake in the Code
                    with open(smali_file_path, 'r') as smali_file:
                        pattern = re.compile(
                            r'([^un]registerReceiver)+(\(.+\))')
                        for index, line in enumerate(smali_file):
                            matched_pattern = pattern.findall(line)
                            if len(matched_pattern) > 0:
                                for matched_pattern_item in matched_pattern:
                                    for item in matched_pattern_item:
                                        if item.startswith('('):
                                            broadcast_item = item.split(';')
                                            if len(broadcast_item) < 4:
                                                self.dyn_broad_rec.add(
                                                    smali_file_path)
                                if len(self.dyn_broad_rec) > 0:
                                    print(
                                        '[+] Found DynamicRegBroadcastReceiver Vulnerability in %s' % smali_file_path)
                                    print(self.dyn_broad_rec)

                    # EmptyPendingIntent
                    with open(smali_file_path, 'r') as smali_file:
                        # Loop through each line in the smali file
                        line_dict = OrderedDict()
                        for index, line in enumerate(smali_file):
                            # Check if the line contains the empty pending intent
                            line_dict[index] = line
                            line_index = 0
                            if 'Landroid/app/PendingIntent;->getService' in line:
                                # Reverse Back the line_dict and find the line which contains the intent
                                for index_reverse in range(index, 0, -1):
                                    if 'Landroid/content/Intent;' in line_dict[index_reverse] and \
                                            'new-instance' in line_dict[index_reverse]:
                                        line_index = index_reverse
                                        break
                                # Check if the intent is empty
                                invoke_intent_line = 0
                                for i in range(line_index, index):
                                    if len(line_dict[i]) > 1:
                                        invoke_intent_line += 1

                                    if 'invoke-direct' in line_dict[i]:
                                        if invoke_intent_line <= 2:
                                            self.empty_pending_intent.add(
                                                smali_file_path)
                                            print(smali_file_path)

                     # Implicit Pending Intent Vulnerability Check
                    # TODO: Split the Logic for Implicit Pending Intent and Empty Pending Intent
                    with open(smali_file_path, 'r') as smali_file:
                        # Loop through each line in the smali file
                        line_dict = OrderedDict()
                        for index, line in enumerate(smali_file):
                            # Check if the line contains the empty pending intent
                            line_dict[index] = line
                            line_index = 0
                            if 'Landroid/app/PendingIntent;->getService' in line:
                                # Reverse Back the line_dict and find the line which contains the intent
                                for index_reverse in range(index, 0, -1):
                                    if 'Landroid/content/Intent;' in line_dict[index_reverse] and \
                                            'new-instance' in line_dict[index_reverse]:
                                        line_index = index_reverse
                                        break
                                # Check if the intent is empty
                                invoke_intent_line = 0
                                for i in range(line_index, index):
                                    if 'ComponentName' in line_dict[i]:
                                        invoke_intent_line += 1

                                if invoke_intent_line == 0:
                                    self.implicit_pending_intent.add(
                                        smali_file_path)
                                    print(smali_file_path)

                     # CheckValidity-InformationExposure Vulnerability Check
                    with open(smali_file_path, 'r') as smali_file:
                        found_trust_manager = False
                        found_check_validity = False
                        for index, line in enumerate(smali_file):
                            if 'Ljavax/net/ssl/X509TrustManager' in line:
                                found_trust_manager = True

                            if found_trust_manager:
                                if 'Ljava/security/cert/X509Certificate' in line and 'checkValidity' in line:
                                    found_check_validity = True
                                    break

                        if not found_check_validity and found_trust_manager:
                            self.ssl_validity_vulnerability.add(
                                smali_file_path)
                            print('[+] SSL Validity Vulnerability: ' +
                                  smali_file_path)

                    # Hostname Verifier Vulnerability Check
                    with open(smali_file_path, 'r') as smali_file:
                        found_host_name_verifier = False
                        host_verify_dict = OrderedDict()
                        for index, line in enumerate(smali_file):
                            if 'Ljavax/net/ssl/HostnameVerifier' in line:
                                found_host_name_verifier = True

                            if found_host_name_verifier:
                                line_count = 0
                                if 'method' in line and 'verify' in line:
                                    host_verify_dict[index] = line
                                    line_count += 1
                                    if '0x1' or '0x0' in line:
                                        self.host_name_verifier_vulnerability.add(
                                            smali_file_path)
                                        print(
                                            '[+] Host Name Verifier Vulnerability: ' + smali_file_path)

                    # Insecure SSL Vulnerability Check
                    with open(smali_file_path, 'r') as smali_file:
                        found_insecure_ssl = False
                        for index, line in enumerate(smali_file):
                            if 'Landroid/net/SSLCertificateSocketFactory' in line:
                                found_insecure_ssl = True

                            if found_insecure_ssl:
                                if 'getInsecure' in line:
                                    self.insecure_ssl_vulnerability.add(
                                        smali_file_path)
                                    print(
                                        '[+] Insecure SSL Vulnerability:' + smali_file_path)

                    # InvalidCertificateAuthority Check
                    with open(smali_file_path, 'r') as smali_file:
                        truster_line = OrderedDict()
                        found_invalid_certificate_authority = False
                        found_server_trust = False
                        for index, line in enumerate(smali_file):
                            if 'Ljavax/net/ssl/X509TrustManager' in line:
                                found_invalid_certificate_authority = True

                            if found_invalid_certificate_authority:
                                if 'checkServerTrusted' in line:
                                    found_server_trust = True

                                if found_server_trust:
                                    print(line)
                                    truster_line[index] = line

                                if 'end method' in line:
                                    found_server_trust = False
                                    if len(truster_line) < 10:
                                        self.invalid_certificate_authority_vulnerability.add(
                                            smali_file_path)
                                        print(
                                            '[+] Invalid Certificate Authority Vulnerability:' + smali_file_path)
                                        break

                    # Unencrypted Socket Communication Check
                    # TODO: Logic Checking Required
                    with open(smali_file_path, 'r') as smali_file:
                        found_unencrypted_socket = False
                        for index, line in enumerate(smali_file):
                            if "Ljava/net/Socket" in line or "Ljava/net/InetSocketAddress" in line or "Ljava/net/SocketAddress" in line \
                                    or "Ljavax/net/SocketFactory" in line:
                                found_unencrypted_socket = True

                            if found_unencrypted_socket:
                                if "Ljavax/net/ssl/SSLSocket" in line or "Ljavax/net/ssl/SSLSocket;->connect" in line \
                                        or "Ljavax/net/ssl/SSLSocket;->isConnected" in line or "Ljava/net/Socket;->isConnected" in line:
                                    self.list_of_unenc_soc.add(smali_file_path)
                                    print(
                                        '[+] Unencrypted Socket Communication Vulnerability:' + smali_file_path)
                                    break
