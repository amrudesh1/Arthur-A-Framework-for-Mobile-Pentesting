# Extract Vulnerability Pattern from Bytecode
import os
import xml.etree.ElementTree as eTree
import re
from collections import OrderedDict


class VulPattern:
    BYTE_CODE_STRING = 'Ljava/lang/String;'
    cbc_pattern = set()
    constant_key_for_pattern = set()
    exposed_credentials_pattern = set()
    dyn_broad_rec = set()
    empty_pending_intent = set()

    def __init__(self, path):
        self.path = path
        self.package_name = self.get_package_name(
            os.path.join(self.path, 'AndroidManifest.xml'))
        self.byte_code_directory = os.path.join(self.path, 'ByteCode')
        self.analyse_byte_code()

    def get_package_name(self, manifest_path):
        xml_tree = eTree.parse(manifest_path)
        root = xml_tree.getroot()
        return root.attrib['package']

    def analyse_byte_code(self):
        if '.' in self.package_name:
            package_name = self.package_name.replace('.', '/')
            byte_code_path = os.path.join(self.path, 'smali', package_name)
        else:
            byte_code_path = os.path.join(
                self.path, 'smali', self.package_name)

        for root, dirs, files in os.walk(byte_code_path):
            print(files)
            for file in files:
                if file.endswith('.smali'):
                    smali_file_path = os.path.join(root, file)

                    # Find AES CBC Vulnerability
                    with open(smali_file_path, 'r') as smali_file:
                        for line in smali_file:
                            if 'AES/ECB/PKCS5Padding' in line or 'AES/ECB/NoPadding' in line or 'AES/ECB' in line:
                                self.cbc_pattern.add(smali_file_path)
                                print(
                                    '[+] Found AES CBC Vulnerability in %s' % smali_file_path)

                    # Find ConstantKey ForgeryAttack Vulnerability (SmartKeySpec Hardcoded Key)
                    # TODO:Variable Check Needs to be Implemented.
                    with open(smali_file_path, 'r') as smali_file:
                        line_count = 0
                        for index, line in enumerate(smali_file):
                            if 'Ljavax/crypto/spec/SecretKeySpec;' in line and 'new-instance' in line:
                                line_count += 1
                            if line_count > 0:
                                if 'sget-object' in line:
                                    break
                                if 'const-string' in line:
                                    self.constant_key_for_pattern.add(
                                        smali_file_path)
                                    print(
                                        '[+] Found ConstantKey ForgeryAttack Vulnerability in %s' % smali_file_path)
                                    break

                    # ExposedCredentials-InformationExposure-Lean
                    # TODO:Variable Check Needs to be Implemented.
                    with open(smali_file_path, 'r') as smali_file:
                        instance_line = False
                        line_count = 0
                        for index, line in enumerate(smali_file):
                            if 'Ljava/security/KeyStore$SecretKeyEntry' and 'new-instance' in line:
                                instance_line = True

                            if instance_line:
                                if 'Ljava/security/KeyStore$SecretKeyEntry' in line:
                                    line_count += 1

                                if line_count > 0:
                                    if (('const/4' in line) or ('const/16' in line)) and ('0x0' in line):
                                        self.exposed_credentials_pattern.add(
                                            smali_file_path)
                    # TODO: Salt Generation Vulnerability Pending

                    # DynamicRegBroadcastReceiver Vulnerability Check
                    # TODO: Check for Logical Mistake in the Code
                    with open(smali_file_path, 'r') as smali_file:
                        pattern = re.compile(
                            r'([^un]registerReceiver)+(\(.+\))')
                        for index, line in enumerate(smali_file):
                            matched_pattern = pattern.findall(line)
                            if len(matched_pattern) > 0:
                                for matched_pattern_item in matched_pattern:
                                    for item in matched_pattern_item:
                                        if item.startswith('('):
                                            broadcast_item = item.split(';')
                                            if len(broadcast_item) < 4:
                                                self.dyn_broad_rec.add(
                                                    smali_file_path)
                                if len(self.dyn_broad_rec) > 0:
                                    print(
                                        '[+] Found DynamicRegBroadcastReceiver Vulnerability in %s' % smali_file_path)
                                    print(self.dyn_broad_rec)

                    # EmptyPendingIntent
                    with open(smali_file_path, 'r') as smali_file:
                        # Loop through each line in the smali file
                        line_dict = OrderedDict()
                        for index, line in enumerate(smali_file):
                            # Check if the line contains the empty pending intent
                            line_dict[index] = line
                            line_index = 0
                            if 'Landroid/app/PendingIntent;->getService' in line:
                                # Reverse Back the line_dict and find the line which contains the intent
                                for index_reverse in range(index, 0, -1):
                                    if 'Landroid/content/Intent;' in line_dict[index_reverse] and \
                                            'new-instance' in line_dict[index_reverse]:
                                        line_index = index_reverse
                                        break
                                # Check if the intent is empty
                                invoke_intent_line = 0
                                for i in range(line_index, index):
                                    if len(line_dict[i]) > 1:
                                        invoke_intent_line += 1

                                    if 'invoke-direct' in line_dict[i]:
                                        if invoke_intent_line <= 2:
                                            self.empty_pending_intent.add(smali_file_path)
                                            print(smali_file_path)
